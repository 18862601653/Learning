# TCPIP详解1协议读书笔记2
## 四、ARP
当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。设备驱动程序从不检查IP数据报中的目的IP地址。  
地址解析为这两种不同的地址形式提供映射：32bit的IP地址和数据链路层使用的任何类型的地址。  
![地址解析协议：ARP和RARP](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-19_162353.png)  

ARP为IP地址到对应的硬件地址之间提供动态映射（自动完成，无需应用程序用户或系统管理员关心），RARP被没有磁盘驱动器的系统使用（需要系统管理员手工设置）。  
### 示例
当敲入以下命令时：
```
ftp 主机名
```
都会执行以下步骤：  
- 应用程序FTP客户端调用函数gethostbyname(3)把主机名转换成32bit的IP地址，这个函数在DNS（域名系统）中称作解析器，这个转换过程或者使用DNS，或者在较小网络中使用一个静态的主机文件（/etc/hosts). 
- FTP客户端请求TCP用得到的IP地址建立连接。  
- TCP发送一个连接请求分段到远端的主机，即用上述IP地址发送一份IP数据报。  
- 如果目的主机在本地网络上（如以太网、令牌环网或点对点链接的另一端），那么IP数据报可以直接送到目的主机上。如果目的主机在一个远程网络上，那就通过IP选路函数来确定位于本地网络上的下一站路由器地址，并让它转发IP数据报。这两种情况下，IP数据报都是被送到位于本地网络上的一台主机或路由器。  
- 假定是一个以太网，那么发送端主机必须把32bit的IP地址变换成48bit的以太网地址。从逻辑Internet地址到对应的物理硬件地址需要进行翻译，这就是ARP的功能，ARP本来是用于广播网络的，有许多主机或路由器连在同一个网络上。  
- ARP发送一份称作ARP请求的以太网数据帧给以太网上的每个主机，这个过程称作广播。ARP请求数据帧中包含目的主机的IP地址，意思是“如果你是这个IP地址的拥有者，请回答你的硬件地址”  
- 目的主机的ARP层收到这份广播报文后，识别出这是发送端在询问它的IP地址，于是发送一个ARP应答。这个ARP应答包含IP地址及对应的硬件地址。  
- 受到ARP应答后，使ARP进行请求-应答交换的IP数据报现在就可以传送了。  
- 发送IP数据报到目的主机。  
![当用户输入命令"ftp 主机名"时ARP的操作](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-19_164306.png)  

网络接口有一个硬件地址（48bit的值，标识不同的以太网或令牌环网络接口），在硬件层次上进行的数据帧交换必须有正确的接口地址，但是TCP/IP有自己的地址：32bit的IP地址。知道主机的IP地址并不能让内核发送一帧数据给主机，内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。ARP的功能是在32bit的IP地址和采用不同网络技术的硬件地址之间提供动态映射。  
点对点链路不使用ARP，当设置这些链路时（一般在引导过程进行），必须告知内核链路每一端的IP地址，不涉及以太网地址这样的硬件地址。  
ARP高效运行的关键是每个主机上都有一个ARP高速缓存，这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。高速缓存中每一项的生存时间一般为20分钟，起始时间从被创建时开始算起。  
```
arp -a
arp检查arp高速缓存，-a显示告诉缓存中所有的内容。
```
48bit的以太网地址用6个十六进制数表示，中间以冒号隔开。  

ARP可用于其他类型的网络，可以解析IP地址以外的地址。  

![用于以太网的ARP请求或应答分组格式](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-19_175840.png)

用于以太网的ARP请求或应答分组格式：  
- 前两个字段是以太网的源地址和目的地址。目的地址为全1的特殊地址是广播地址，电缆上所有以太网接口都有接收广播的数据帧。  
- 两个字节长的以太网帧类型表示后面数据的类型，对于ARP请求或应答来说，该字段的值为0x0806.  
- 硬件和协议用来描述ARP分组中的各个字段。如，一个ARP请求分组询问协议地址（这里指IP地址）对应的硬件地址（这里指以太网地址）。硬件类型字段表示硬件地址的类型，值为1表示以太网地址，协议类型字段表示要映射的协议地址类型，值为0x0800表示IP地址。它的值与包含IP数据报的以太网数据帧中的类型字段值相同。  
- 硬件地址长度和协议地址长度都是1字节的字段，分别指硬件地址和协议地址的长度，以字节为单位，对于以太网上IP地址的ARP请求或应答来说，它们的值分别是6和4.  
- 操作字段指出四种操作类型，它们是ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）。这个字段是必需的，因为ARP请求和ARP应答的帧类型字段值是相同的。  
- 最后四个字段是发送端的硬件地址（本例中是以太网地址）、 发送端的协议地址（IP地址）、 目的端的硬件地址和目的端的协议地址。在以太网的数据帧报头中和ARP请求数据帧中都有发送端的硬件地址。  
对于一个ARP请求来说，除了目的端硬件地址外的所有其他的字段都有填充值，当系统收到一份目的端为本机的ARP请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为2，最后发送回去。  

```
arp -a 检验arp高速缓存是空的
telnet svr4 discard 连接无效的服务器
```
![TCP连接请求产生的ARP请求和应答](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-20_214154.png)  

- 第一行中，源端主机（bsdi）的硬件地址是0:0:c0:6f:2d:40，目的端主机的硬件地址是ff:ff:ff:ff:ff:ff，这是一个以太网广播地址。电缆上的每个以太网接口都要接受这个数据帧并对它进行处理。  
- 第一行紧接着的一个输出字段是arp，表明帧类型字段的值是0x0806，说明此数据帧是一个arp请求或回答。  
- arp或ip后的值60指的是以太网数据帧的长度。arp请求或应答的数据帧长都是42字节（28字节的arp数据，14字节的以太网帧头），因而每一帧都必须加入填充字符以达到以太网的最小长度要求：60字节。60字节包括14字节的以太网帧头，不包括4个字节的以太网帧尾。  
- arp who-has表示作为arp请求的这个数据帧中，目的IP地址是svr4的地址，发送端的IP地址是bsdi的地址，tcpdump打印出主机名对应的默认IP地址。  
- 虽然arp请求时广播的，但是arp应答的目的地址却是bsdi（0:0:c0:6f:2d:40)，arp应答是直接送到请求端主机的，而不是广播的。  
- tcpdump打印出arp reply的字样，同时打印出响应者的主机名和硬件地址。   
- 第三行是第一个请求建立连接的TCP段，目的硬件地址是目的主机（svr4）。  
- 行号后面的数字表示tcpdump收到分组的时间（单位是秒），除第一行外，其他每行在括号中还包含了与上一行的时间差异（单位秒）。本例中发送arp请求与收到arp应答之间的时延是2.2ms，在0.7ms之后发出第一段tcp报文。本例中arp动态地址解析的时间小于3ms。
- 在svr4发出第一段tcp报文之前没有发出arp请求，可能是因为在svr4的arp高速缓存中已经有bsdi的表项。一般情况下，当系统收到arp请求或发送arp应答时，都要把请求端的硬件地址和IP地址存入ARP高速缓存。  

当查询到主机已经关机或不存在时：  
![对不存在主机的arp请求](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-20_220712.png)  

第一次请求后5.5秒进行第二次请求，24s后进行第三次请求。tcpdump命令输出的超时限制是29.5s。但是在telnet命令使用前后分别用date命令检查时间，可以发现Telnet客户端的连接请求在75s后才放弃。大多数的BSD实现把完成TCP连接请求的时间限制设置为75s。  
在线路上始终看不到tcp的报文段，能看到的是arp请求，直到arp回答返回时，tcp报文段才可以被发送，因为硬件地址到此时才可能知道，如果使用过滤模式运行tcpdump只查看tcp数据，将没有任何输出。  

在ARP高速缓存中的表项一般都要设置超时值，管理员可以用arp命令把地址放入高速缓存而不设置超时值。一般对完整的表项设置超时值为20分钟，对不完整的表项设置超时值为3分钟，当这些表项再次使用时，这些实现一般都把超时值重新设为20分钟。  

如果ARP请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作委托ARP或ARP代理。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。  
ARP代理也称作混合ARP或ARP出租。  
ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。这样两个物理网络可以使用相同的网络号，只要把中间的路由器设置为一个ARP代理，以响应一个网络到另一个网络主机的ARP请求。这种技术在过去用来隐藏一组在不同物理电缆上运行旧版TCP/IP的主机，分开这些旧主机有两个共同的理由：1）它们不能处理子网划分，2）它们使用旧的广播地址（所有比特值为0的主机号，而不是目前使用的所有比特值为1的主机号）。  

免费ARP：指主机发送ARP查找自己的IP地址，通常发生在系统引导期间进行接口配置的时候。  
发送端的协议地址和目的端的协议地址是一致的。  
tcpdump命令-n选项打印出点分十进制地址，而不是主机名。  
免费ARP作用：  
1. 一个主机可以通过它来确定另一个主机是否设置了相同的IP地址  
2. 如果发送免费ARP的主机正好改变了硬件地址（可能主机关机了，并换了一块接口卡，然后重启），那么这个分组就可以使其他主机高速缓存中旧的硬件地址进行相应的更新。  
```
arp -a :显示arp高速缓存中的所有内容
-d ：删除arp高速缓存中的某一项内容
-s :增加高速缓存中的内容，这个参数需要主机名和以太网地址，对应于主机名的IP地址和以太网地址被增加到高速缓存中，新增加的内容是永久性的，除非在命令行的末尾附加上关键字temp。
位于命令行末尾的关键字pub和-s一起，可以使系统起着主机arp代理的作用，系统将回答与主机名对应的IP地址的arp请求，并以指定的以太网地址作为应答，如果广播的地址是系统本身，那么系统就为指定的主机名起着委托arp代理的作用。  

```

### tcpdump
tcpdump，dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析，支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句帮助去除无用的信息。  
tcpdump通过将网络接口卡设置为混杂模式来截获经过网络接口的每一个分组。正常情况下，用于诸如以太网媒体的接口卡指截获送往特定接口地址或广播地址的链路层的帧。  
底层的操作系统必须允许将一个接口设置成混杂模式，并且允许一个用户进程截获帧。  
BSD分组过滤器BPF（BSD Packet Filter），tcpdump用它来截获和过滤来自一个被置为混杂模式的网络接口卡的分组。BFP也可以工作在点对点的链路上，如SLIP，不需要什么特别的处理就可以截获所有通过接口的分组，BPF还可以工作在环回接口上。  
![BSD分组过滤器](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-19_194310.png)  

BPF将以太网设备驱动程序设置为混杂模式，然后从驱动程序那里接收每一个收到的分组和传输的分组。这些分组要通过一个用户指明的过滤器，使得只有那些用户进程感兴趣的分组才会传递给用户进程。  
多个进程可以同时监视一个接口，每个进程指明一个自己的过滤器。  
tcpdump的过滤器可以由用户在命令行指明，而rarpd总是使用只截获RARP请求的过滤器。  
BPF的每个用户除了指明一个过滤器外，还指明一个超时定时器的值，因为网络的数据传输率可以很容易地超过CPU的处理能力，而且一个用户进程从内核中只读小块数据的代价昂贵，所以BPF尝试将多个帧装载进一个读缓存，只有缓存满了或者用户指明的超时到期才将读缓存保存的帧返回。tcpdump将超时定时器置为1秒，因为它一般从BPF收到很多数据，而RARP守护进程收到的帧很少，所以rarpd将超时置为0（即收到一个帧就返回）。  

用户指明的过滤器告诉BPF用户进程对什么帧感兴趣，过滤器是对一个假想机器的一组指令。这些指令被内核中的BPF过滤器解释，在内核中过滤，而不在用户进程中，减少了必须从内核传递到用户进程的数据量。RARP守护进程总是使用绑定在程序里的、同样的过滤程序。tcpdump在每次运行时，让用户在命令行指明一个过滤表达式。tcpdump将用户指明的表达式转换为相应的BPF的指令序列。  
```
tcpdump tcp port 25
只打印源端口和目的端口为25的TCP报文段
tcpdump 'icmp [0] != 8 and icmp[0] !=0'
只打印不是回送请求和回送应答的ICMP报文（非ping的分组），ICMP报文第一个字节8表示回送请求，0表示回送应答。用引号括起来是为了防止Unix外壳程序解释特殊字符。  
```

SunOS 4.1.x提供了一个STREAMS伪设备驱动程序，称为网络接口分接头或NIT（包含了流设备驱动程序的其他细节）。NIT类似于BSD分组过滤器，但在功能上没有BSD强大，效率也没有BSD高。BPF可以截获网络接口收到的和传送的分组，NIT只能截获接口收到的分组。tcpdump与NIT结合意味着只能看到由网络中其他主机发送来的分组，而不能看到自己主机发送的分组。
![SunOS的网络接口分接头](https://github.com/Balabalabalala/Learning/blob/master/images/tcpip/2018-04-19_225515.png)

当设备/dev/nit被打开时，流驱动程序nit_if就会被打开。因为NIT是使用流来构造的，所以处理模块可以放在nit_if驱动程序之上。tcpdump将模块nit_buf放在STREAM之上，这个模块将多个网络帧聚集在一个读缓存中，允许用户进程指明一个超时的值。RARP守护进程没有把这个模块放在它的流之上，因为它只处理了一小部分分组。用户指明的过滤由流模块nit_pf处理，这个模块被RARP守护进程所用，但没有被tcpdump使用。在SunOS操作系统中，tcpdump代之以在用户进程中完成自己的过滤操作。因为nit_pf使用的假想机器的指令与BPF所支持的指令不同，也就意味着当用户对tcpdump指明了一个过滤表达式时，与BPF相比，使用NIT就会有更多的数据在内核与用户进程之间交换。   

SVR4支持数据链路提供者接口DLPI（Data Link Provider Interface），是OSI数据链路服务定义的一个流实现。向tcpdump的网络监视程序必须使用DLPI来直接访问数据链路设备驱动程序。  

tcpdump输出：  
基本上tcpdump的输出格式为：系统时间 来源主机.端口 > 目标主机.端口 数据包参数  
tcpdump的输出格式与协议有关  
- 链路层头
对于FDDI网络，'-e'使tcpdump打印出指定数据包的'frame control'域，源和目的地址，以及包的长度。frame control域控制对包中其他域的解析，一般的包（如IP datagrams）都是带有'async'（异步标志）的数据包，并且有取值0到7的优先级，如'async4'代表此包为异步数据包，优先级为4.通常这些包内含一个LLC包（逻辑链路控制包），如果此包不是一个ISO datagram或所谓的SNAP包，其LLC头部会被打印。  
对于Token Ring网络（令牌环网络）,'-e'使tcpdump打印出指定数据包的'frame control'和'access control'域，以及源和目的地址，外加包的长度。与FDDI网络类似，此数据包通常内含LLC数据包，不管是否有'-e'选项，对于此网络上的'source-routed'（源地址被追踪的数据包）类型数据包，其包的源路由信息总会被打印。  
对于802.11网络（WLAN，wireless local area network），'-e'使tcpdump打印出指定数据包的'frame control域，包头中包含的所有地址，以及包的长度，与FDDI网络类似，此数据包通常内含LLC数据报。  
对于SLIP网络，即通过串行线路建立的连接，数据包的'direction indicator'（方向指示标志，I表示入，O表示出），类型及压缩信息会被打印，包类型会被首先打印。  
类型分为ip、utcp、ctcp，对于ip包，连接信息不被打印，对于tcp数据包，连接标识紧接着类型表示被打印，如果此包被压缩，被编码过的头部将被打印。  
对于特殊的压缩包，会显示\*S+n或者\*SA+n，n代表包的顺序号和应答号增加或减少的数目。  
对于非特殊的压缩包，0个或更多的'改变'将会被打印，'改变'被打印时格式：  
'标志'+/-/=n 包数据的长度 压缩的头部长度  
其中标志可以是U（紧急指针）、W（缓冲窗口）、A（应答）、S（序列号）、I（包ID），增量表达'=n'表示被赋予新的值，+/-表示增加或减少。  

- ARP/PARP数据包
tcpdump对arp/rarp包的输出信息中会包含请求类型及该请求对应的参数。  
从主机rtsg到主机csam的'rlogin'(远程登陆）过程开始阶段的数据包样例：  
```
arp who-has csam tell rtsg 
trsg发送了一个arp数据包（向全网段发送）以询问csam的以太网地址
arp reply csam is-at CSAM

如果使用tcpdump -n，可以清晰地看到以太网以及ip地址而不是名字标识：
arp who-has 128.3.254.6 tell 128.3.254.68
arp reply 128.3.254.6 is-at 02:07:01:00:01:c4

如果使用tcpdump -e，可以清晰地看到第一个数据包时全网广播的，第二个数据包时点对点的：
RTSG Broadcast 0806 64: arp who-has csam tell rtsg
以arp包的源以太地址是RTSG，目的地址是全以太网段，type域的值为16进制0806，包的总长度为64字节
CSAM RTSG 0806 64: arp reply csam is-at CSAM
```




截获网络中传输的数据流能看到很多不该看到的东西，如Telnet和FTP用户输入的口令在网络中传输的内容和用户输入的一样（口令的明文表示）。tcpdump及其他类似的工具的访问权限依赖于具体系统。  
查看一个TCP连接上发生的事情的另一种方法是使能插口排错选项，这个特征只能工作在TCP上（其他协议不行）。

```
1、默认启动：
tcpdump：普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。
2、监视指定网络接口的数据包
tcpdump -i eth1：如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0.
3、监视指定主机的数据包
tcpdump host sundow:打印所有进入或离开sundown的数据包
tcpdump host 172.29.173.111:指定ip，截获指定ip的主机收到的和发出的所有的数据包
tcpdump host helios and \(hot or ace\):打印helios与hot或者ace之间通信的数据包
tcpdump host ip1 and \(ip2 or ip3\):截获ip1指定的主机与ip2指定的主机或ip3指定的主机之间的通信
tcpdump ip host ace and not helios:打印ace与除了helios外的其他任何主机之间通信的IP数据包
tcpdump ip host ip1 and !ip2:获取ip1指定的主机与ip2指定的主机之外所有主机通信的ip包
tcpdump -i eth0 src host hostname:截获主机hostname发送的所有数据
tcpdump -i eth0 dst host hostname：监视所有送到主机hostname的数据包
4、监视指定主机和端口的数据包
tcpdump tcp port 23 and host ip1：获取ip1指定的主机接收或发出的telnet包
tcpdump udp port 123：对本机的upd 123端口进行监视，123为ntp服务端口
5、监视指定网络的数据包
tcpdump net ucb-ether：打印本地主机与网络地址为ucb-ether的网络上的主机之间的所有通信数据包
tcpdump 'gateway snup and (port ftp or ftp-data)':打印所有通过网关snup的ftp数据包，用引号防止shell对括号进行错误解析
tcpdump ip and not net localnet：打印所有源地址或目的地址是本地主机的IP数据包（如果本地网络通过网关连到了另一网络，则另一网络并不能算作本地网络，localnet是本地网络名
6、监视指定协议的数据包
tcpdump 'tcp[tcpflags] & (tcp-syn|tcp-fin) != 0 and not src and dst net localnet':打印TCP会话中的开始和结束数据包，并且数据包的源或目的不是本地网络上的主机
tcpdump 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)':
打印所有源或目的端口是80，网络层协议为IPv4，并且含有数据，而不是SYN，FIN以及ACK-only等不含数据的数据包。
ip[2:2]表示整个ip数据包的长度
(ip[0]&0xf)<<2表示ip数据包包头的长度（ip[0]&0xf代表包中的IHL域，而此域的单位为32bit，要换算成字节数需要乘以4，即左移2.
(tcp[12]&0xf0)>>4表示tcp头的长度，此域的单位也是32bit，换算成比特数为((tcp[12]&0xf0)>>4)<<2,即(tcp[12]&0xf0)>>2
((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0表示整个ip数据包的长度减去ip头的长度，再减去tcp头的长度，结果不为0，意味着ip数据包中确实是有数据。对于IPv6版本只需考虑ipv6头中的'Payload Length'与'tcp头的长度'的差值，并且其中表达方式'ip[]'需要换成'ip6[]'
tcpdump 'gateway snup and ip[2:2] > 576':打印长度超过576字节，并且网关地址是snup的IP数据包
tcpdump 'ether[0] & 1 = 0 and ip[16] >= 224':打印所有IP层广播或多播的数据包，但不是物理以太网层的广播或多播数据报
tcpdump 'icmp[icmptype] != icmp-echo and icmp[icmptype] != icmp-echoreply':打印除'echo request'或者'echo reply'类型以外的ICMP数据包，如需打印所有非ping程序产生的数据包时可用到此表达式，‘echo request’和‘echo reply’这两种类型的ICMP数据包通常由ping程序产生
7、tcpdump与wireshark
tcpdump tcp -i eth1 -t -s 0 -c 100 and dst port ! 22 and src net 192.168.1.0/24 -w ./target.cap
(1)tcp:ip icmp arp rarp 和tcp udp icmp这些选项要放在第一个参数的位置，用来过滤数据报的类型
(2)-i eth1：只抓经过接口eth1的包
(3)-t：不显示时间戳
(4)-s 0:抓取数据包时默认抓取长度为68字节，加上-s 0后可以抓到完整的数据包
(5)-c 100:只抓取100个数据包
(6)dst port ! 22:不抓取目标端口是22的数据包
(7)src net 192.168.1.0/24：数据包的源网络地址为192.168.1.0/24
(8)-w ./target.cap：保存成cap文件，方便用wireshark分析
8、使用tcpdump抓取HTTP包
tcpdump -XvvennSs 0 -i eth0 tcp[20:2]=0x4745 or tcp[20:2]=0x4854
0x4745为GET前两个字母GE，0x4854为HTTP前两个字母HT
tcpdump对截获的数据并没有进行彻底解码，数据包内的大部分内容是使用进制的形式直接打印输出的。者不利于分析网络故障，通常使用带-w参数的tcpdump截获数据并保存到文件中，然后再使用其他程序进行解码分析，还需要定义过滤规则，防止捕获的数据包填满整个硬盘
```







## 参考
[1] https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html
